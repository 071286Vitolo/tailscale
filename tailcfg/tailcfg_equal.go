// Copyright (c) Tailscale Inc & AUTHORS
// SPDX-License-Identifier: BSD-3-Clause

// Code generated by tailscale.com/cmd/equaler; DO NOT EDIT.

package tailcfg

import (
	"net/netip"
	"time"

	"golang.org/x/exp/slices"
	"tailscale.com/types/key"
	"tailscale.com/types/opt"
	"tailscale.com/types/structs"
	"tailscale.com/types/tkatype"
)

// Equal reports whether a and b are equal.
func (a *Node) Equal(b *Node) bool {
	if a == b {
		return true
	}
	return a != nil && b != nil &&
		a.ID == b.ID &&
		a.StableID == b.StableID &&
		a.Name == b.Name &&
		a.User == b.User &&
		a.Sharer == b.Sharer &&
		a.Key == b.Key &&
		a.KeyExpiry.Equal(b.KeyExpiry) &&
		((a.KeySignature == nil) == (b.KeySignature == nil)) &&
		slices.Equal(a.KeySignature, b.KeySignature) &&
		a.Machine == b.Machine &&
		a.DiscoKey == b.DiscoKey &&
		((a.Addresses == nil) == (b.Addresses == nil)) &&
		slices.Equal(a.Addresses, b.Addresses) &&
		((a.AllowedIPs == nil) == (b.AllowedIPs == nil)) &&
		slices.Equal(a.AllowedIPs, b.AllowedIPs) &&
		((a.Endpoints == nil) == (b.Endpoints == nil)) &&
		slices.Equal(a.Endpoints, b.Endpoints) &&
		a.DERP == b.DERP &&
		a.Hostinfo.Equal(b.Hostinfo) &&
		a.Created.Equal(b.Created) &&
		a.Cap == b.Cap &&
		((a.Tags == nil) == (b.Tags == nil)) &&
		slices.Equal(a.Tags, b.Tags) &&
		((a.PrimaryRoutes == nil) == (b.PrimaryRoutes == nil)) &&
		slices.Equal(a.PrimaryRoutes, b.PrimaryRoutes) &&
		((a.LastSeen == nil) == (b.LastSeen == nil)) && (a.LastSeen == nil || a.LastSeen.Equal(*b.LastSeen)) &&
		((a.Online == nil) == (b.Online == nil)) && (a.Online == nil || *a.Online == *b.Online) &&
		a.KeepAlive == b.KeepAlive &&
		a.MachineAuthorized == b.MachineAuthorized &&
		((a.Capabilities == nil) == (b.Capabilities == nil)) &&
		slices.Equal(a.Capabilities, b.Capabilities) &&
		a.UnsignedPeerAPIOnly == b.UnsignedPeerAPIOnly &&
		a.ComputedName == b.ComputedName &&
		a.computedHostIfDifferent == b.computedHostIfDifferent &&
		a.ComputedNameWithHost == b.ComputedNameWithHost &&
		a.DataPlaneAuditLogID == b.DataPlaneAuditLogID &&
		a.Expired == b.Expired &&
		((a.SelfNodeV4MasqAddrForThisPeer == nil) == (b.SelfNodeV4MasqAddrForThisPeer == nil)) && (a.SelfNodeV4MasqAddrForThisPeer == nil || *a.SelfNodeV4MasqAddrForThisPeer == *b.SelfNodeV4MasqAddrForThisPeer) &&
		a.IsWireGuardOnly == b.IsWireGuardOnly &&
		true
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _NodeEqualNeedsRegeneration = Node(struct {
	ID                            NodeID
	StableID                      StableNodeID
	Name                          string
	User                          UserID
	Sharer                        UserID
	Key                           key.NodePublic
	KeyExpiry                     time.Time
	KeySignature                  tkatype.MarshaledSignature
	Machine                       key.MachinePublic
	DiscoKey                      key.DiscoPublic
	Addresses                     []netip.Prefix
	AllowedIPs                    []netip.Prefix
	Endpoints                     []string
	DERP                          string
	Hostinfo                      HostinfoView
	Created                       time.Time
	Cap                           CapabilityVersion
	Tags                          []string
	PrimaryRoutes                 []netip.Prefix
	LastSeen                      *time.Time
	Online                        *bool
	KeepAlive                     bool
	MachineAuthorized             bool
	Capabilities                  []string
	UnsignedPeerAPIOnly           bool
	ComputedName                  string
	computedHostIfDifferent       string
	ComputedNameWithHost          string
	DataPlaneAuditLogID           string
	Expired                       bool
	SelfNodeV4MasqAddrForThisPeer *netip.Addr
	IsWireGuardOnly               bool
}{})

// Equal reports whether a and b are equal.
func (a *Hostinfo) Equal(b *Hostinfo) bool {
	if a == b {
		return true
	}
	return a != nil && b != nil &&
		a.IPNVersion == b.IPNVersion &&
		a.FrontendLogID == b.FrontendLogID &&
		a.BackendLogID == b.BackendLogID &&
		a.OS == b.OS &&
		a.OSVersion == b.OSVersion &&
		a.Container == b.Container &&
		a.Env == b.Env &&
		a.Distro == b.Distro &&
		a.DistroVersion == b.DistroVersion &&
		a.DistroCodeName == b.DistroCodeName &&
		a.App == b.App &&
		a.Desktop == b.Desktop &&
		a.Package == b.Package &&
		a.DeviceModel == b.DeviceModel &&
		a.PushDeviceToken == b.PushDeviceToken &&
		a.Hostname == b.Hostname &&
		a.ShieldsUp == b.ShieldsUp &&
		a.ShareeNode == b.ShareeNode &&
		a.NoLogsNoSupport == b.NoLogsNoSupport &&
		a.WireIngress == b.WireIngress &&
		a.AllowsUpdate == b.AllowsUpdate &&
		a.Machine == b.Machine &&
		a.GoArch == b.GoArch &&
		a.GoArchVar == b.GoArchVar &&
		a.GoVersion == b.GoVersion &&
		((a.RoutableIPs == nil) == (b.RoutableIPs == nil)) &&
		slices.Equal(a.RoutableIPs, b.RoutableIPs) &&
		((a.RequestTags == nil) == (b.RequestTags == nil)) &&
		slices.Equal(a.RequestTags, b.RequestTags) &&
		((a.Services == nil) == (b.Services == nil)) &&
		slices.EqualFunc(a.Services, b.Services, func(aa Service, bb Service) bool { return aa.Equal(&bb) }) &&
		((a.NetInfo == nil) == (b.NetInfo == nil)) && (a.NetInfo == nil || a.NetInfo.Equal(b.NetInfo)) &&
		((a.SSH_HostKeys == nil) == (b.SSH_HostKeys == nil)) &&
		slices.Equal(a.SSH_HostKeys, b.SSH_HostKeys) &&
		a.Cloud == b.Cloud &&
		a.Userspace == b.Userspace &&
		a.UserspaceRouter == b.UserspaceRouter &&
		true
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _HostinfoEqualNeedsRegeneration = Hostinfo(struct {
	IPNVersion      string
	FrontendLogID   string
	BackendLogID    string
	OS              string
	OSVersion       string
	Container       opt.Bool
	Env             string
	Distro          string
	DistroVersion   string
	DistroCodeName  string
	App             string
	Desktop         opt.Bool
	Package         string
	DeviceModel     string
	PushDeviceToken string
	Hostname        string
	ShieldsUp       bool
	ShareeNode      bool
	NoLogsNoSupport bool
	WireIngress     bool
	AllowsUpdate    bool
	Machine         string
	GoArch          string
	GoArchVar       string
	GoVersion       string
	RoutableIPs     []netip.Prefix
	RequestTags     []string
	Services        []Service
	NetInfo         *NetInfo
	SSH_HostKeys    []string
	Cloud           string
	Userspace       opt.Bool
	UserspaceRouter opt.Bool
}{})

// Equal reports whether a and b are equal.
func (a *NetInfo) Equal(b *NetInfo) bool {
	if a == b {
		return true
	}
	return a != nil && b != nil &&
		a.MappingVariesByDestIP == b.MappingVariesByDestIP &&
		a.HairPinning == b.HairPinning &&
		a.WorkingIPv6 == b.WorkingIPv6 &&
		a.OSHasIPv6 == b.OSHasIPv6 &&
		a.WorkingUDP == b.WorkingUDP &&
		a.WorkingICMPv4 == b.WorkingICMPv4 &&
		a.HavePortMap == b.HavePortMap &&
		a.UPnP == b.UPnP &&
		a.PMP == b.PMP &&
		a.PCP == b.PCP &&
		a.PreferredDERP == b.PreferredDERP &&
		a.LinkType == b.LinkType &&
		// Skipping DERPLatency because of codegen:noequal
		true
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _NetInfoEqualNeedsRegeneration = NetInfo(struct {
	MappingVariesByDestIP opt.Bool
	HairPinning           opt.Bool
	WorkingIPv6           opt.Bool
	OSHasIPv6             opt.Bool
	WorkingUDP            opt.Bool
	WorkingICMPv4         opt.Bool
	HavePortMap           bool
	UPnP                  opt.Bool
	PMP                   opt.Bool
	PCP                   opt.Bool
	PreferredDERP         int
	LinkType              string
	DERPLatency           map[string]float64
}{})

// Equal reports whether a and b are equal.
func (a *Service) Equal(b *Service) bool {
	if a == b {
		return true
	}
	return a != nil && b != nil &&
		// Skipping _ because of codegen:noequal
		a.Proto == b.Proto &&
		a.Port == b.Port &&
		a.Description == b.Description &&
		true
}

// A compilation failure here means this code must be regenerated, with the command at the top of this file.
var _ServiceEqualNeedsRegeneration = Service(struct {
	_           structs.Incomparable
	Proto       ServiceProto
	Port        uint16
	Description string
}{})
